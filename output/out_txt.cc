/*
 *	out_txt.cc
 */

/*	Copyright (C) 1999, 2000, 2001 Sebastian Biallas (sb@web-productions.de)
 *
 *	This program is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License version 2 as
 *	published by the Free Software Foundation.
 *
 *	This program is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with this program; if not, write to the Free Software
 *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include "analy_names.h"
#include "htdebug.h"
#include "htinfo.h"
#include "out_txt.h"
#include "tools.h"
#include "x86dis.h"

int write_str2(ht_stream *stream, char *s)
{
	return stream->write(s, strlen(s));
}

char txt_buffer[1024];

int generate_txt_output(Analyser *analy, ht_stream *stream, Address *from, Address *to)
{
#if 0
	if ((!analy) || (!stream)) return TXT_OUTPUT_ERR_GENERIC;
	if (analy->active) return TXT_OUTPUT_ERR_ANALY_NOT_FINISHED;

	write_str2(stream, "Analysis of ");
	write_str2(stream, analy->getname());
	write_str2(stream, "\n");
	write_str2(stream, "generated by "ht_name" version "ht_version".\n\n");
	// main loop:
	ADDR Addr = from;
	while (1) {
		if (Addr > to) break;

		taddr *a = analy->findaddr(Addr);

		int length = 0;

		char temp[1024];

		sprintf(temp, HEX8FORMAT8, Addr);
		write_str2(stream, temp);


		if (analy->explored->contains(Addr)) {
			write_str2(stream, "!");
		} else {
			write_str2(stream, " ");
		}


		if (a) {
			write_str2(stream, " ");
			// comments
			tcomment *c = a->comments;
			if (c) {
//				write_str2(stream, "");
				while (c)	{
					write_str2(stream, c->text);
					write_str2(stream, "\n");
					c = c->next;
				}
//				write_str2(stream, "\n");
			}
			// label
			write_str2(stream, "");
			if (a->label) {
				sprintf(temp, "<b>%s</b>:<br>\n", a->label->name);
				write_str2(stream, temp);
			}
		} else {
			write_str2(stream, "<td width=500>");
		}

		if (analy->validcodeaddr(Addr)) {
			taddr *nextaddr = analy->enum_addrs(Addr);
			int op_len;

			if (nextaddr) {
				op_len = MIN((dword)analy->maxopcodelength, (nextaddr->addr - Addr));
			} else {
				op_len = analy->maxopcodelength;
			}

			if (analy->disasm) {
				OPCODE *o=analy->disasm->decode((byte *)analy->bufptr(Addr), op_len, analy->mapaddr(Addr));
				addr_sym_func = 0;
				sprintf(temp, "  %s", analy->disasm->str(o, X86DIS_STYLE_HEX_NOZEROPAD));
				length=analy->disasm->getsize(o);
			} else {
				sprintf(temp, "  db      0x%02x", *(byte *)analy->bufptr(Addr));
				length=1;
			}
		} else {
			if (analy->validaddr(Addr, scvalid)) {
				if ((a) && (a->type.type == dtint)) {
					length = a->type.length;
					assert(length);
					byte c;
					if (analy->validaddr(Addr, scinitialized)) {
						switch (a->type.intsubtype) {
							case dstiword:
								sprintf(temp, "  dw      0x%04x", *(word *)analy->bufptr(Addr));
								break;
							case dstidword:
								sprintf(temp, "  dd      0x%08x", *(dword *)analy->bufptr(Addr));
								break;
							case dstibyte:
							default:
								c = *(byte *)analy->bufptr(Addr);
								sprintf(temp, "  db      0x%02x ; `%c'", c, (c<32)?32:c);
						}
					} else {
						switch (a->type.intsubtype) {
							case dstiword:
								strcpy(temp, "  dw      ????");
								break;
							case dstidword:
								strcpy(temp, "  dd      ????????");
								break;
							case dstibyte:
							default:
								strcpy(temp, "  db      ??");
						}
					}
				} else {
					length =	1;
					if (analy->validaddr(Addr, scinitialized)) {
						byte c = *(byte *)analy->bufptr(Addr);
						sprintf(temp, "  db      0x%02x ; `%c'", c, (c<32)?32:c);
					} else {
						strcpy(temp, "  db      ??");
					}
				}
			} else {
				ADDR next = analy->nextvalid(Addr);
				if (next != INVALID_ADDR) {
					length = next - Addr;
					sprintf(temp, "  db      ?? * %d", next - Addr);
				} else {
					length =	1;
					strcpy(temp, "  db      ??");
				}
			}
		}
/*		if (mode & ANALY_EDIT_BYTES) {
			if (validaddr(Addr, scinitialized)) {

				FILEADDR a=fileaddr(Addr);
				assert(a != INVALID_FILE_OFS);
				for (int i=0; i<(*length); i++) {
					buf = tag_make_edit_byte(buf, a+i);
				}
				for (int i=0; i<=(maxopcodelength*2)-(*length)*2; i++) {
					*(buf++)=' ';
				}
				*buf=0;
			}
		}*/

		char *t = temp;
		while (*t) {
			if ((t[0]==' ') && (t[1]==' ')) {
				write_str2(stream, "&nbsp;");
			} else {
				stream->write(t, 1);
			}
			t++;
		}

		if (a) {
			write_str2(stream, "</td>\n<td>");
			txref *x = a->xreflist;
			int i=0;
			while (x)	{
				if (i % 3==0) {
					write_str2(stream, ";xref");
				}
				sprintf(temp, " %c<a href=\"#A%08X\">"HEX8FORMAT"</a>", xref_type_short(x->type), x->addr, x->addr);
				write_str2(stream, temp);
				if (i % 3==2) {
					write_str2(stream, "<br>\n");
				}
				i++;
				x = x->next;
			}
			write_str2(stream, "</td>\n</tr></table>");
		}
		write_str2(stream, "</td>\n</tr>\n");

		Addr += length;
	}
	// end
	write_str2(stream, "</table>\n");
#endif
	return TXT_OUTPUT_OK;
}
